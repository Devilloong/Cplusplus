【目录】
1.多线程知识
2.
3.
4.


【正文】
1.多线程知识
  （来源课程【C++并发与多线程编程】）
  ---p3:课时3：线程启动、结束、创建多线程方法、join、detach.
      内容：
       1)范例演示线程运行的开始和结束
          1.1)thread
          1.2)join()
          1.3)detach()
          1.4)joinable()
       2)其他创建线程的手法
          2.1)用类，以及一个问题范例
          2.2)用lambda表达式
     
     ①一般来说，主线程创建完后，子线程也会被销毁
     ②当使用detach时，如果子线程有地址依赖于主线程中的零时变量，
     当主线程结束后，如果子线程还有任务没有完成，将会给程序带来不可预料的后果。
     
     如:
     #include <iostream>
     #include <thread>
     
     class Ta{
       public:
       int m_i;
       Ta(int& i) : m_i(i) {}
       
        void operator()(){
            std::cout << "1_i = " << m_i << std::endl;
            std::cout << "2_i = " << m_i << std::endl;
            std::cout << "3_i = " << m_i << std::endl;
            std::cout << "4_i = " << m_i << std::endl;
        }
     };
     
     int main(){
        int i = 5;
        Ta ta(i);
        std::thread t(ta);
        ta.detach();
        
        std::cout << "This is main thread." << std::endl;
        
        return 0;
     }
  
    这种情况时，detach会引起一个bug。假如主线程执行完后，ta的空间将会被释放，但是子线程中还引用着i的地址，会产生不可预料的错误。
    
 ---p4 课时4 线程传参详解,detach()大坑，成员函数做线程函数
     内容：
      1）传递临时对象作为线程参数
          1.1）要避免的陷阱（解释1）
          1.2）要避免的陷阱（解释2）
          1.3）总结
      2）临时对象作为线程参数继续讲
          2.1）线程id的概念
          2.2）临时对象构造时机抓捕
      3）传递类对象、智能指针作为线程参数
      4）用成员函数指针做线程函数
      
      detach大坑之一：变量值传递时，当函数参数为值引用时，在多线程情况下，可能是一个假引用（形参引用的变量地址和原变量地址不同），
            而引入指针传递时，指针参数地址和指针变量相同，会造成主线程结束后，指针地址也会被销毁。
      
2.
3.
4.
